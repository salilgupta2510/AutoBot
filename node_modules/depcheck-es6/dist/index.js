'use strict';

var _defineProperty = require('babel-runtime/helpers/define-property')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign2 = require('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = depcheck;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _walkdir = require('walkdir');

var _walkdir2 = _interopRequireDefault(_walkdir);

var _minimatch = require('minimatch');

var _minimatch2 = _interopRequireDefault(_minimatch);

var _component = require('./component');

var _component2 = _interopRequireDefault(_component);

var _utilsGetNodes = require('./utils/get-nodes');

var _utilsGetNodes2 = _interopRequireDefault(_utilsGetNodes);

var _requirePackageName = require('require-package-name');

var _requirePackageName2 = _interopRequireDefault(_requirePackageName);

function constructComponent(source, name) {
  return source[name].reduce(function (result, current) {
    return _Object$assign2(result, _defineProperty({}, current, require(_path2['default'].resolve(__dirname, name, current))));
  }, {});
}

var availableParsers = constructComponent(_component2['default'], 'parser');

var availableDetectors = constructComponent(_component2['default'], 'detector');

var availableSpecials = constructComponent(_component2['default'], 'special');

var defaultOptions = {
  withoutDev: false,
  ignoreBinPackage: true,
  ignoreMatches: [],
  ignoreDirs: ['.git', '.svn', '.hg', '.idea', 'node_modules', 'bower_components'],
  parsers: {
    '*.js': availableParsers.jsx,
    '*.jsx': availableParsers.jsx,
    '*.coffee': availableParsers.coffee,
    '*.litcoffee': availableParsers.coffee,
    '*.coffee.md': availableParsers.coffee
  },
  detectors: [availableDetectors.importDeclaration, availableDetectors.requireCallExpression, availableDetectors.gruntLoadTaskCallExpression],
  specials: []
};

function getOrDefault(opt, key) {
  return typeof opt[key] !== 'undefined' ? opt[key] : defaultOptions[key];
}

function unifyParser(parsers) {
  return _Object$assign2.apply(Object, [{}].concat(_toConsumableArray(_Object$keys(parsers).map(function (key) {
    return _defineProperty({}, key, parsers[key] instanceof Array ? parsers[key] : [parsers[key]]);
  }))));
}

function safeDetect(detector, node) {
  try {
    return detector(node);
  } catch (error) {
    return [];
  }
}

function minus(array1, array2) {
  return array1.filter(function (item) {
    return array2.indexOf(item) === -1;
  });
}

function intersect(array1, array2) {
  return array1.filter(function (item) {
    return array2.indexOf(item) !== -1;
  });
}

function unique(array) {
  return array.filter(function (value, index) {
    return array.indexOf(value) === index;
  });
}

function isStringArray(obj) {
  return obj instanceof Array && obj.every(function (item) {
    return typeof item === 'string';
  });
}

function getDependencies(dir, filename, deps, parser, detectors) {
  return new _Promise(function (resolve, reject) {
    _fs2['default'].readFile(filename, 'utf8', function (error, content) {
      if (error) {
        reject(error);
      }

      try {
        resolve(parser(content, filename, deps, dir));
      } catch (syntaxError) {
        reject(syntaxError);
      }
    });
  }).then(function (ast) {
    var _ref3;

    // when parser returns string array, skip detector step and treat them as dependencies directly.
    if (isStringArray(ast)) {
      return ast;
    }

    // matrix looks like [ /* node1 */ [d1, d2], /* node2 */ [d1, d2], ...]
    var matrix = (0, _utilsGetNodes2['default'])(ast).map(function (node) {
      var _ref2;

      return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(detectors.map(function (detector) {
        return safeDetect(detector, node);
      })));
    });

    var dependencies = unique((_ref3 = []).concat.apply(_ref3, _toConsumableArray(matrix))).map(_requirePackageName2['default']);

    return dependencies;
  });
}

function checkFile(dir, filename, deps, devDeps, parsers, detectors) {
  var _ref4;

  var basename = _path2['default'].basename(filename);
  var targets = (_ref4 = []).concat.apply(_ref4, _toConsumableArray(_Object$keys(parsers).filter(function (glob) {
    return (0, _minimatch2['default'])(basename, glob, { dot: true });
  }).map(function (key) {
    return parsers[key];
  })));

  return targets.map(function (parser) {
    return getDependencies(dir, filename, deps.concat(devDeps), parser, detectors).then(function (used) {
      return {
        dependencies: minus(deps, used),
        devDependencies: minus(devDeps, used)
      };
    }, function (error) {
      return {
        dependencies: deps,
        devDependencies: devDeps,
        invalidFiles: _defineProperty({}, filename, error)
      };
    });
  });
}

function checkDirectory(dir, ignoreDirs, deps, devDeps, parsers, detectors) {
  return new _Promise(function (resolve) {
    var promises = [];
    var finder = (0, _walkdir2['default'])(dir, { 'no_recurse': true });

    finder.on('directory', function (subdir) {
      return ignoreDirs.indexOf(_path2['default'].basename(subdir)) === -1 && promises.push(checkDirectory(subdir, ignoreDirs, deps, devDeps, parsers, detectors));
    });

    finder.on('file', function (filename) {
      return promises.push.apply(promises, _toConsumableArray(checkFile(dir, filename, deps, devDeps, parsers, detectors)));
    });

    finder.on('error', function (dirPath, error) {
      return promises.push(_Promise.resolve({
        dependencies: deps,
        devDependencies: devDeps,
        invalidDirs: _defineProperty({}, dirPath, error)
      }));
    });

    finder.on('end', function () {
      return resolve(_Promise.all(promises).then(function (results) {
        return results.reduce(function (obj, current) {
          return {
            dependencies: intersect(obj.dependencies, current.dependencies),
            devDependencies: intersect(obj.devDependencies, current.devDependencies),
            invalidFiles: _Object$assign2(obj.invalidFiles, current.invalidFiles),
            invalidDirs: _Object$assign2(obj.invalidDirs, current.invalidDirs)
          };
        }, {
          dependencies: deps,
          devDependencies: devDeps,
          invalidFiles: {},
          invalidDirs: {}
        });
      }));
    });
  });
}

function isIgnored(ignoreMatches, dependency) {
  return ignoreMatches.some(function (match) {
    return (0, _minimatch2['default'])(dependency, match);
  });
}

function hasBin(rootDir, dependency) {
  try {
    var depPkg = require(_path2['default'].join(rootDir, 'node_modules', dependency, 'package.json'));
    return depPkg.hasOwnProperty('bin');
  } catch (error) {
    return false;
  }
}

function filterDependencies(rootDir, ignoreBinPackage, ignoreMatches, dependencies) {
  return _Object$keys(dependencies).filter(function (dependency) {
    return ignoreBinPackage && hasBin(rootDir, dependency) || isIgnored(ignoreMatches, dependency) ? false : true;
  });
}

function depcheck(rootDir, options, cb) {
  var withoutDev = getOrDefault(options, 'withoutDev');
  var ignoreBinPackage = getOrDefault(options, 'ignoreBinPackage');
  var ignoreMatches = getOrDefault(options, 'ignoreMatches');
  var ignoreDirs = unique(defaultOptions.ignoreDirs.concat(options.ignoreDirs));

  var detectors = getOrDefault(options, 'detectors');
  var parsers = _Object$assign2({ '*': getOrDefault(options, 'specials') }, unifyParser(getOrDefault(options, 'parsers')));

  var metadata = options['package'] || require(_path2['default'].join(rootDir, 'package.json'));
  var dependencies = metadata.dependencies || {};
  var devDependencies = metadata.devDependencies || {};
  var deps = filterDependencies(rootDir, ignoreBinPackage, ignoreMatches, dependencies);
  var devDeps = filterDependencies(rootDir, ignoreBinPackage, ignoreMatches, withoutDev ? [] : devDependencies);

  return checkDirectory(rootDir, ignoreDirs, deps, devDeps, parsers, detectors).then(cb);
}

depcheck.parser = availableParsers;
depcheck.detector = availableDetectors;
depcheck.special = availableSpecials;
module.exports = exports['default'];